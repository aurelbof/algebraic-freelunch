

# This file was *autogenerated* from the file input.sage
from sage.all_cmdline import *   # import sage library

_sage_const_1 = Integer(1); _sage_const_28407454060060787 = Integer(28407454060060787); _sage_const_3 = Integer(3); _sage_const_0 = Integer(0); _sage_const_4 = Integer(4); _sage_const_10 = Integer(10); _sage_const_2 = Integer(2); _sage_const_7 = Integer(7); _sage_const_5 = Integer(5); _sage_const_12 = Integer(12); _sage_const_14 = Integer(14); _sage_const_6 = Integer(6); _sage_const_8 = Integer(8); _sage_const_21 = Integer(21)
from hashlib import shake_256
from math import log2,ceil

set_verbose(-_sage_const_1 )
p = _sage_const_28407454060060787 
p_bits = ceil(log2(p))
Fp = FiniteField(p)
assert((p-_sage_const_1 ) % _sage_const_3  != _sage_const_0 )
inv_3 = pow(_sage_const_3 ,-_sage_const_1 ,p-_sage_const_1 )

alphas = [_sage_const_0 ,_sage_const_0 ] + [_sage_const_4 *(i+_sage_const_1 ) for i in range(_sage_const_10 )]
gammas = [_sage_const_0 ,_sage_const_0 ] + [i+_sage_const_1  for i in range(_sage_const_10 )]
betas = [_sage_const_0 ,_sage_const_0 ] + [(i+_sage_const_1 )**_sage_const_2  * _sage_const_7  for i in range(_sage_const_10 )]

set_random_seed(int.from_bytes(b"Griffin","little"))

R = _sage_const_5 
#3 rounds bypassed
assert(R>=_sage_const_3 )
b = _sage_const_12 

RC = []
for r in range(R-_sage_const_1 ):
    RC.append([])
    for branch in range(b):
        RC[r].append(Fp.random_element())
RC.append([])
for branch in range(b):
    RC[R-_sage_const_1 ].append(Fp(_sage_const_0 ))

# print(f"{RC}")
print('print round constants')

for r in range(R):
    for i in range(b):
        print(RC[r][i])
    print()

# write the first two round constants in a dedicated file
with open('../first_two_constants.txt','w') as f:
    for r in range(_sage_const_2 ):
        for i in range(b):
            f.write(f'{RC[r][i]}\n')
f.close()

# write the other constants in a file in the same folder. Remember nvars = R-2
with open(f'constants{R-_sage_const_2 }.txt','w') as g:
    for r in range(_sage_const_2 ,R):
        for i in range(b):
            g.write(f'{RC[r][i]}\n')
g.close()
#Non-linear layer:

def F(i,s,new_s,leading_term=False):
    Li = gammas[i]*new_s[_sage_const_0 ] + new_s[_sage_const_1 ] + (s[i-_sage_const_1 ] if i > _sage_const_2  else _sage_const_0 )
    if not leading_term:
        return (Li**_sage_const_2  + alphas[i]*Li + betas[i])
    else:
        return Li**_sage_const_2 

def non_linear_layer(s,zero=False,leading_term=False):
    new_s = []
    # Supposing that s[0] is only a constant, else the next step is impossible
    # The condition s[0][1] == 0 will be posed later
    if zero:
        new_s = [_sage_const_0 ,_sage_const_0 ]
    else:
        new_s.append(s[_sage_const_0 ]**(inv_3))
        new_s.append(s[_sage_const_1 ]**_sage_const_3 )
    for i in range(_sage_const_2 ,_sage_const_12 ):
        new_s.append(F(i,s,new_s,leading_term=leading_term)*s[i])

    return new_s

def non_linear_layer_with_new_variable(s,z):
    new_s = []
    # Supposing that s[0] is only a constant, else the next step is impossible
    # The condition s[0][1] == 0 will be posed later
    new_eq = (s[_sage_const_0 ][_sage_const_0 ] - z**_sage_const_3 )
    new_s.append(z)
    new_s.append(s[_sage_const_1 ][_sage_const_0 ]**_sage_const_3 )
    for i in range(_sage_const_2 ,_sage_const_12 ):
        new_s.append(F(i,s,new_s)*s[i])

    return new_s,new_eq

def non_linear_layer_with_new_variable_and_mod(s,z,eqs):
    new_s = []
    # Supposing that s[0] is only a constant, else the next step is impossible
    # The condition s[0][1] == 0 will be posed later
    new_eq = (s[_sage_const_0 ] - z**_sage_const_3 )
    new_s.append(z)
    s1 = (s[_sage_const_1 ]**_sage_const_2 ).mod(eqs)
    new_s.append((s1 * s[_sage_const_1 ]).mod(eqs))
    for i in range(_sage_const_2 ,_sage_const_12 ):
        new_s.append((F(i,s,new_s).mod(eqs)*s[i]).mod(eqs))
        new_s[-_sage_const_1 ] = new_s[-_sage_const_1 ].mod(eqs)

    return new_s,new_eq

def linear_layer(s):
    return list(M*vector(s))

def affine_layer(s, RCi):
    s_2 = linear_layer(s)
    return  [s+c for (s,c) in zip(s_2,RCi)]

# Linear Matrix
M = matrix(Fp, [[_sage_const_10 ,_sage_const_14 ,_sage_const_2 ,_sage_const_6 ,_sage_const_5 ,_sage_const_7 ,_sage_const_1 ,_sage_const_3 ,_sage_const_5 ,_sage_const_7 ,_sage_const_1 ,_sage_const_3 ],[_sage_const_8 ,_sage_const_12 ,_sage_const_2 ,_sage_const_2 ,_sage_const_4 ,_sage_const_6 ,_sage_const_1 ,_sage_const_1 ,_sage_const_4 ,_sage_const_6 ,_sage_const_1 ,_sage_const_1 ],[_sage_const_2 ,_sage_const_6 ,_sage_const_10 ,_sage_const_14 ,_sage_const_1 ,_sage_const_3 ,_sage_const_5 ,_sage_const_7 ,_sage_const_1 ,_sage_const_3 ,_sage_const_5 ,_sage_const_7 ],[_sage_const_2 ,_sage_const_2 ,_sage_const_8 ,_sage_const_12 ,_sage_const_1 ,_sage_const_1 ,_sage_const_4 ,_sage_const_6 ,_sage_const_1 ,_sage_const_1 ,_sage_const_4 ,_sage_const_6 ],[_sage_const_5 ,_sage_const_7 ,_sage_const_1 ,_sage_const_3 ,_sage_const_10 ,_sage_const_14 ,_sage_const_2 ,_sage_const_6 ,_sage_const_5 ,_sage_const_7 ,_sage_const_1 ,_sage_const_3 ],[_sage_const_4 ,_sage_const_6 ,_sage_const_1 ,_sage_const_1 ,_sage_const_8 ,_sage_const_12 ,_sage_const_2 ,_sage_const_2 ,_sage_const_4 ,_sage_const_6 ,_sage_const_1 ,_sage_const_1 ],[_sage_const_1 ,_sage_const_3 ,_sage_const_5 ,_sage_const_7 ,_sage_const_2 ,_sage_const_6 ,_sage_const_10 ,_sage_const_14 ,_sage_const_1 ,_sage_const_3 ,_sage_const_5 ,_sage_const_7 ],[_sage_const_1 ,_sage_const_1 ,_sage_const_4 ,_sage_const_6 ,_sage_const_2 ,_sage_const_2 ,_sage_const_8 ,_sage_const_12 ,_sage_const_1 ,_sage_const_1 ,_sage_const_4 ,_sage_const_6 ],[_sage_const_5 ,_sage_const_7 ,_sage_const_1 ,_sage_const_3 ,_sage_const_5 ,_sage_const_7 ,_sage_const_1 ,_sage_const_3 ,_sage_const_10 ,_sage_const_14 ,_sage_const_2 ,_sage_const_6 ],[_sage_const_4 ,_sage_const_6 ,_sage_const_1 ,_sage_const_1 ,_sage_const_4 ,_sage_const_6 ,_sage_const_1 ,_sage_const_1 ,_sage_const_8 ,_sage_const_12 ,_sage_const_2 ,_sage_const_2 ],[_sage_const_1 ,_sage_const_3 ,_sage_const_5 ,_sage_const_7 ,_sage_const_1 ,_sage_const_3 ,_sage_const_5 ,_sage_const_7 ,_sage_const_2 ,_sage_const_6 ,_sage_const_10 ,_sage_const_14 ],[_sage_const_1 ,_sage_const_1 ,_sage_const_4 ,_sage_const_6 ,_sage_const_1 ,_sage_const_1 ,_sage_const_4 ,_sage_const_6 ,_sage_const_2 ,_sage_const_2 ,_sage_const_8 ,_sage_const_12 ]])

M_inv = M.inverse()

# Polynomial field representing 
# Ai are linear components after 1st linear layer
# Bi are constant components after 1st linear layer
# z is a new variables needed for 2nd non-linear layer



def compute_states_from_Ai(A2,B2,A4,B4,A6,B6,A8,B8,A11,B11,z):
    x_polynomial_ring = PolynomialRing(constant_ring,'X')
    X, = x_polynomial_ring.gens()


    M_in_x = matrix(x_polynomial_ring,M)
    # Compute the round function for the first few rounds

    # constant components
    state_b = [_sage_const_0 ,_sage_const_0 ,B2,_sage_const_0 ,B4,_sage_const_0 ,B6,_sage_const_0 ,B8,_sage_const_0 ,_sage_const_0 ,B11] 
    # linear components (multiplied by x)
    state_a = [_sage_const_0 ,_sage_const_0 ,A2,_sage_const_0 ,A4,_sage_const_0 ,A6,_sage_const_0 ,A8,_sage_const_0 ,_sage_const_0 ,A11] 


    #state after first linear layer
    state_x = [state_a[i]*X + state_b[i] for i in range(_sage_const_12 )]


    # state at input (first element is 0 for CICO constaints)
    state_input =  M_inv * vector(state_x)

    #state after first non linear layer
    state_x_after_first_S = non_linear_layer(state_x)


    #state after first affine layer (second application of matrix M)
    state_x_after_first_affine_layer = affine_layer(state_x_after_first_S, RC[_sage_const_0 ])


    #state after second non linear layer

    state_x_after_second_S,eq_z = non_linear_layer_with_new_variable(state_x_after_first_affine_layer,z)


    #State after second linear layer

    state_x_after_second_affine_layer = affine_layer(state_x_after_second_S, RC[_sage_const_1 ])
    return state_input,state_x, state_x_after_first_S,state_x_after_first_affine_layer,state_x_after_second_S,state_x_after_second_affine_layer,eq_z




#First step, compute the A2,A4,A6,A8,A10
constant_ring = PolynomialRing(Fp,'A2,A4,A6,A8,A11',order="lex")

A2,A4,A6,A8,A11 = constant_ring.gens()

betas = [_sage_const_0 ,_sage_const_0 ] + [(i+_sage_const_1 )**_sage_const_2  * _sage_const_7  for i in range(_sage_const_10 )]
state_a = [_sage_const_0 ,_sage_const_0 ,A2,_sage_const_0 ,A4,_sage_const_0 ,A6,_sage_const_0 ,A8,_sage_const_0 ,_sage_const_0 ,A11] 

state_input = M_inv * vector(state_a)
state_after_first_affine_layer = M*vector([b*s for (b,s) in zip(betas,state_a)])

state_after_second_non_linear_layer = non_linear_layer(state_after_first_affine_layer,zero=True,leading_term=True)



state_after_second_non_linear_layer = vector(state_after_second_non_linear_layer)

state_after_second_affine_layer = M* vector(state_after_second_non_linear_layer)


#state_input,state_x, state_x_after_first_S,state_x_after_first_affine_layer,state_x_after_second_S,state_x_after_second_affine_layer,eq_z = compute_states_from_Ai(A2,0,A4,0,A6,0,A8,0,A10,0,0)


leading_coefficient = []

#First equation: the first input word is 0 :
eq1 = state_input[_sage_const_0 ]
#Second and third equations, the linear component after first affine layer is 0
eq2 = state_after_first_affine_layer[_sage_const_0 ]
eq3 = state_after_first_affine_layer[_sage_const_1 ]

#Fourth and fifth equations, the degree 3 component after second affine layer is 0:

eq4 = state_after_second_affine_layer[_sage_const_0 ]
eq5 = A11 - _sage_const_2 #state_after_second_affine_layer[1]




eq_system = [eq1,eq2,eq3,eq4,eq5]

#for eq in eq_system:
#    print(eq)
Id = constant_ring.ideal(eq_system)

#id_gb = Id.groebner_basis()
#print(id_gb)
#print(id_gb[-1])
#print(id_gb[-1].factor())
id_var = Id.variety()

#print(len(id_var))
#print(id_var)
a2,a4,a6,a8,a11 = id_var[-_sage_const_1 ]["A2"],id_var[-_sage_const_1 ]["A4"],id_var[-_sage_const_1 ]["A6"],id_var[-_sage_const_1 ]["A8"],id_var[-_sage_const_1 ]["A11"]
#print(f"a2, a4, a6, a8, a11 = {a2}, {a4}, {a6}, {a8}, {a11}")
inp = M_inv * vector(Fp, [_sage_const_0 , _sage_const_0 , a2, _sage_const_0 , a4, _sage_const_0 , a6, _sage_const_0 , a8, _sage_const_0 , _sage_const_0 , a11])

assert(inp[_sage_const_0 ] == _sage_const_0 )




# Second step: compute the B2,B4,B6,B8,B10,z

constant_ring = PolynomialRing(Fp,'B2,B4,B6,B8,B11,z',order="lex")


B2,B4,B6,B8,B11,z = constant_ring.gens()

state_input,state_x, state_x_after_first_S,state_x_after_first_affine_layer,state_x_after_second_S,state_x_after_second_affine_layer,eq_z = compute_states_from_Ai(a2,B2,a4,B4,a6,B6,a8,B8,a11,B11,z)


# First equation: the first input word is 0 (constant components = 0)
eq1 = state_input[_sage_const_0 ][_sage_const_0 ]

#2nd, 3rd, 4th, 5th equations: the degree 1 and 2 components of 1st and 2nd wire after second affine layer is 0

eq2 = state_x_after_second_affine_layer[_sage_const_0 ][_sage_const_1 ]
eq3 = state_x_after_second_affine_layer[_sage_const_0 ][_sage_const_2 ]
eq4 = B2 - _sage_const_1 
eq5 = B4 - _sage_const_1 

#6th equation: eqz
eq6 = eq_z

eq_system = [eq1,eq2,eq3,eq4,eq5,eq6]

#print([e.degree() for e in state_x_after_second_S])
#print([e.degree() for e in state_x_after_second_affine_layer])

Id = constant_ring.ideal(eq_system)

id_var = Id.variety()

b2,b4,b6,b8,b11,z = id_var[-_sage_const_1 ]["B2"], id_var[-_sage_const_1 ]["B4"],id_var[-_sage_const_1 ]["B6"],id_var[-_sage_const_1 ]["B8"],id_var[-_sage_const_1 ]["B11"], id_var[-_sage_const_1 ]["z"]
#print("Groebner basis computed...")

# print(A.right_kernel())
# Vector space of degree 5 and dimension 2 over Finite Field of size 28407454060060787
# Basis matrix:
# [                1                 0 24856522302553193                 0  3550931757507597]
# [                0                 1 27786299816764997 27827710099651383  5452353913374155]

# a2, a4, a6, a8, a10 = A.right_kernel().random_element()
#print(f"A2,B2,A4,B4,A6,B6,A8,B8,A11,B11 = {a2}, {b2}, {a4}, {b4}, {a6}, {b6}, {a8}, {b8}, {a11}, {b11}")
inp_a = M_inv * vector(Fp, [_sage_const_0 , _sage_const_0 , a2, _sage_const_0 , a4, _sage_const_0 , a6, _sage_const_0 , a8, _sage_const_0 , _sage_const_0 , a11])

inp_b = M_inv * vector(Fp, [_sage_const_0 , _sage_const_0 , b2, _sage_const_0 , b4, _sage_const_0 , b6, _sage_const_0 , b8, _sage_const_0 , _sage_const_0 , b11])


# Given the a_i, compute the state after 3 rounds of Griffin.
# the Griffin weight vector
W = [(_sage_const_7 )**i * _sage_const_7  + _sage_const_1  for i in range(R-_sage_const_3 )] + [_sage_const_1 ]

x_polynomial_ring = PolynomialRing(Fp,','.join(f"z{i}" for i in range(R-_sage_const_3 ))+',X',order=TermOrder('wdeglex',W))
z = list(x_polynomial_ring.gens())[:-_sage_const_1 ]
X = list(x_polynomial_ring.gens())[-_sage_const_1 ]

state_inp  = [a*X + b for (a,b) in zip(inp_a,inp_b)]

assert(state_inp[_sage_const_0 ]==_sage_const_0 )

print('Interesting line')
for i in range(_sage_const_12 ):
    print(state_inp[i])

state_after_first_linear_layer = linear_layer(state_inp)


state_after_first_non_linear_layer = non_linear_layer(state_after_first_linear_layer)

state_after_first_affine_layer = affine_layer(state_after_first_non_linear_layer,RC[_sage_const_0 ])


state_after_second_non_linear_layer = non_linear_layer(state_after_first_affine_layer)


state_after_second_affine_layer = affine_layer(state_after_second_non_linear_layer,RC[_sage_const_1 ])


state_after_third_non_linear_layer = non_linear_layer(state_after_second_affine_layer)

# state_after_third_affine_layer = affine_layer(state_after_third_non_linear_layer, RC[2])


# state_after_third_non_linear_layer is the starting point of the system.

# print(state_after_third_non_linear_layer)
indexvar = R-_sage_const_2 
with open('third_state.txt', 'w') as f:
    for inp in state_after_third_non_linear_layer:
        s = str(inp).replace('X',f'z{indexvar}')
        for j in range(_sage_const_21 ,-_sage_const_1 ,-_sage_const_1 ):
            s = s.replace(f'z{indexvar}^{j} ', f'z{indexvar}^{_sage_const_3 *j} ')
        s = s.replace(f'*z{indexvar} ', f'*z{indexvar}^3 ')
        s = s.replace(' ', '')
        f.write(s + '\n')

# state_after_4plusith_non_linear_layer = state_after_third_non_linear_layer
# eqs = []
# for i in range(R-3):
#    state_after_3plusith_affine_layer = affine_layer(state_after_4plusith_non_linear_layer,RC[2+i])
#    state_after_4plusith_non_linear_layer,new_eq = non_linear_layer_with_new_variable_and_mod(state_after_3plusith_affine_layer,z[i],eqs)
#    eqs.append(new_eq)
#    print(new_eq)
#    #print(eqs)

# state_after_3plusith_affine_layer = affine_layer(state_after_4plusith_non_linear_layer,RC[R-1])
# print([state_after_3plusith_affine_layer] + eqs)











